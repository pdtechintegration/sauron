(function() {
  var EventEmitter, Log, StockedItem, cleanUp, config, currentStock, getItem, log, normalizeURL, querystring, removeItem, request, stockCount, url, xml2js;
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }, __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  };
  EventEmitter = require('events').EventEmitter;
  url = require('url');
  querystring = require('querystring');
  request = require('request');
  xml2js = require('xml2js');
  Log = require('coloured-log');
  log = new Log();
  currentStock = {};
  stockCount = 0;
  config = {
    shelfLife: 60,
    maxLife: 300,
    capacity: 1000,
    ideal: 900,
    caseSensitive: true,
    verbosity: "INFO",
    xmlOptions: {}
  };
  log.notice("Initializing the Pantry");
  log.info("Configuration: shelfLife=" + config.shelfLife + ", maxLife=" + config.maxLife + ", capacity=" + config.capacity + ", ideal=" + config.ideal);
  this.configure = function(options) {
    var k, v;
    for (k in options) {
      v = options[k];
      config[k] = v;
    }
    if (!(options.ideal && config.ideal <= (config.capacity * 0.9))) {
      config.ideal = config.capacity * 0.9;
    }
    log.notice("Updated configuration");
    log.info("Configuration: shelfLife=" + config.shelfLife + ", maxLife=" + config.maxLife + ", capacity=" + config.capacity + ", ideal=" + config.ideal);
    return config;
  };
  this.fetch = function(options, callback) {
    var k, stockedItem, v, _ref, _ref2;
    for (k in config) {
      v = config[k];
      if ((_ref = options[k]) == null) {
        options[k] = v;
      }
    }
    if ((_ref2 = options.key) == null) {
      options.key = normalizeURL(options.uri, options.caseSensitive);
    }
    if ((options.method != null) && options.method !== 'GET') {
      options.maxLife = 0;
    }
    stockedItem = getItem(options);
    if (stockedItem.hasSpoiled()) {
      stockedItem.once('stocked', __bind(function(error, results) {
        return callback(error, results);
      }, this));
    } else {
      callback(null, stockedItem.results);
    }
    if (stockedItem.hasExpired()) {
      return stockedItem.fetch(options);
    }
  };
  this.getStock = function(callback) {
    var stock;
    stock = {};
    stock.currentStock = currentStock;
    stock.stockCount = stockCount;
    return callback(null, stock);
  };
  normalizeURL = function(value, caseSensitive) {
    var k, keys, query, uri, _i, _len;
    if (caseSensitive == null) {
      caseSensitive = false;
    }
    uri = url.parse(value, true);
    keys = [];
    for (k in uri.query) {
      keys.push(k);
    }
    keys.sort();
    query = {};
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      k = keys[_i];
      if (uri.query.hasOwnProperty(k)) {
        query[caseSensitive ? k : k.toLowerCase()] = uri.query[k];
      }
    }
    uri.search = querystring.stringify(query);
    if (!caseSensitive) {
      uri.pathname = uri.pathname.toLowerCase();
    }
    return url.format(uri);
  };
  getItem = function(options) {
    if (!(currentStock[options.key] != null)) {
      currentStock[options.key] = new StockedItem(options);
      stockCount++;
      cleanUp();
    }
    return currentStock[options.key];
  };
  removeItem = function(key) {
    delete currentStock[key];
    return stockCount--;
  };
  cleanUp = function() {
    var expired, item, key, _i, _len;
    if (stockCount > config.capacity) {
      log.warning("We're over capacity " + stockCount + " / " + config.ideal + ".  Time to clean up the pantry");
      expired = [];
      for (key in currentStock) {
        item = currentStock[key];
        if (item.results != null) {
          if (item.hasSpoiled()) {
            log.info("Spoiled " + key);
            removeItem(key);
          } else if (item.hasExpired()) {
            expired.push(key);
          }
        }
      }
      if (stockCount > config.capacity) {
        for (_i = 0, _len = expired.length; _i < _len; _i++) {
          key = expired[_i];
          log.warning("Expired " + key);
          removeItem(key);
          if (stockCount <= config.ideal) {
            break;
          }
        }
      }
      if (stockCount > config.capacity) {
        for (key in currentStock) {
          item = currentStock[key];
          if (item.results) {
            log.alert("Tossed " + key);
            removeItem(key);
            if (stockCount <= config.ideal) {
              break;
            }
          }
        }
      }
      return log.notice("Cleanup complete.  Currently have " + stockCount + " items in stock");
    }
  };
  StockedItem = (function() {
    __extends(StockedItem, EventEmitter);
    function StockedItem(options) {
      this.options = options;
      this.loading = false;
    }
    StockedItem.prototype.hasExpired = function() {
      return this.hasSpoiled() || (new Date()) > this.bestBefore;
    };
    StockedItem.prototype.hasSpoiled = function() {
      return !(this.results != null) || (new Date()) > this.spoilesOn;
    };
    StockedItem.prototype.fetch = function(options) {
      var _base, _ref;
      this.options = options;
      if (this.loading) {
        return;
      }
      this.loading = true;
      if ((_ref = (_base = this.options).headers) == null) {
        _base.headers = {};
      }
      if (this.eTag) {
        this.options.headers['if-none-match'] = this.eTag;
      }
      if (this.lastModified) {
        this.options.headers['if-modified-since'] = this.lastModified;
      }
      return request(this.options, __bind(function(error, response, body) {
        var contentType, match, parser, start;
        match = /max-age=(\d+)/.exec(response.headers['cache-control']);
        if (match && !this.options.ignoreCacheControl) {
          this.options.shelfLife = parseInt(match[1]);
        }
        if (error == null) {
          switch (response.statusCode) {
            case 304:
              log.info("Still Good " + options.key);
              return this.stock(response, null);
            case 200:
              log.notice("Re-stocked " + options.key);
              contentType = response.headers["content-type"];
              if (this.options.parser === 'json' || contentType.indexOf('application/json') === 0) {
                return this.stock(response, JSON.parse(body));
              } else if (this.options.parser === 'xml' || contentType.search(/[\/\+]xml/) > 0) {
                start = body.indexOf('<');
                if (start) {
                  body = body.slice(start, body.length);
                }
                parser = new xml2js.Parser(this.options.xmlOptions);
                parser.on('end', __bind(function(results) {
                  return this.stock(response, results);
                }, this));
                return parser.parseString(body);
              } else {
                return this.oops("Invalid Response Type (" + contentType + ")");
              }
              break;
            default:
              return this.oops("Invalid Response Code (" + response.statusCode + ")");
          }
        }
      }, this));
    };
    StockedItem.prototype.stock = function(response, results) {
      this.loading = false;
      if (this.firstPurchased != null) {
        this.lastPurchased = new Date();
      } else {
        this.firstPurchased = new Date();
        this.lastPurchased = new Date(this.firstPurchased);
      }
      this.lastUsed = new Date(this.lastPurchased);
      this.bestBefore = new Date(this.lastPurchased);
      this.bestBefore.setSeconds(this.bestBefore.getSeconds() + this.options.shelfLife);
      this.spoilesOn = new Date(this.lastPurchased);
      this.spoilesOn.setSeconds(this.spoilesOn.getSeconds() + this.options.maxLife);
      this.eTag = response.headers['etag'];
      this.lastModified = response.headers['last-modified'];
      if (results != null) {
        this.results = results;
      }
      return this.emit('stocked', null, this.results);
    };
    StockedItem.prototype.oops = function(error) {
      this.loading = false;
      log.error("" + error);
      return this.emit('stocked', error);
    };
    return StockedItem;
  })();
}).call(this);
