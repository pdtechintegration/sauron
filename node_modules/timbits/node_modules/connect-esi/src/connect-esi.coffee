http = require 'http'
url = require 'url'
querystring = require 'querystring'
out = (require 'styout').instance 'connect-esi'

out.verbosity = out.WARN_VERBOSITY

exports.setupESI = ->
	handleESI = (req, res, next) ->
		endCalled = false
		endWait = false

		# MODIFY res.writeHead
		###
		writeHead = res.writeHead
		res.writeHead = (statusCode, reasonPhrase, headers) ->
			out.debug "res.writeHead | statusCode: " + statusCode + " | req.url: " + req.url
			out.debug res._headers
			res.writeHead = writeHead
			res.writeHead statusCode, reasonPhrase, headers
			return
		####

		# MODIFY res.write
		write = res.write  # store the original function
		res.write = (chunk, encoding) -> # wrap write to hook into the exit path through the layers
			res.write = write # put the original back
			ignoreESI = /esi=false/.test(req.url)
			content_type = 	if res._headers? and res._headers['content-type']? then	res._headers['content-type'] else 'text/plain' # if no content-type is provided, set to 'text/plain'
			out.debug "res.write | content-type: " + content_type + " | req.url: " + req.url
			re = /text|xml|octet-stream/i
			if re.test(content_type) && ignoreESI is false # only process ESIs if response data contains text
				endWait = true
				esiProcessor = new exports.processESI chunk, (err, chunk) ->
					out.debug "processESI callback | req.url: " + req.url
					###
					lengthInUtf8Bytes = (str) ->
						m = encodeURIComponent(str).match(/%[89ABab]/g)
						str.length + (if m then m.length else 0)
					####
					res.setHeader 'content-type', content_type
					#res.setHeader 'content-length', lengthInUtf8Bytes(chunk)
					res.setHeader 'transfer-encoding', 'chunked'
					res.writeHead res.statusCode ? 200
					endWait = false
					res.write chunk, encoding # call the original on callback
					if endCalled
						res.end()
				esiProcessor.request = req.headers
				esiProcessor.request.url = url.parse('http://' + req.headers['host'] + req.url, true)
				esiProcessor.execute()
			else
				res.write chunk, encoding # call the original
				if endCalled
					res.end()
			return

		# MODIFY res.end
		end = res.end
		res.end = (data, encoding) ->
			endCalled = true
			out.debug "res.end | data: " + data? + " | wait: " + endWait + " | req.url: " + req.url
			if data?
				res.write data, encoding
			else if endWait == false # if not waiting (for async)
				res.end = end
				res.end()
			return

		next() # pass through to the next layer

exports.processESI = (data, callback) ->
	@original = data
	@data = data.toString()
	@callback = callback
	@request = {'url': url.parse('http://localhost:5678')} # set default host
	@esi_tags = []
	@processed = false

	@execute = ->
		out.info "Searching for ESIs..."
		@esi_tags = @searchESI @data
		out.info "Found " + @esi_tags.length + " ESIs"
		if (@esi_tags.length != 0) # there are ESIs to process
			for esi_tag in @esi_tags
				out.info "Fetch ESI: " + esi_tag
				@fetchESI esi_tag, (src, status, body) =>
					if status >= 400
						body = '' # remove error messages from body if http status is 4xx or 5xx
						out.warn "ESI: " + src + " returned status " + status
					else
						out.debug "ESI: " + src + " returned status " + status
					out.info "ESI tag subsitution: " + src
					remaining = @subESI src, body
					out.info remaining + " remaining ESIs"
					if remaining == 0 and @processed is false # no remaining ESIs to process, callback
						@processed = true # flag to prevent callback from ever being called twice
						@callback false, @data
		else
			@callback false, @original # send back original, unmodified data

	@searchESI = (data) ->
		re = new RegExp('<esi[^>]* src=("[^>"]+"|\'[^>\']+\')[^>]*>(</esi[^>]*>)?', 'gi')
		esi_tags = data.match(re)
		for k of esi_tags
			re = new RegExp(' src=("(.*?)"|\'(.*?)\')')
			match = esi_tags[k].match(re)
			esi_tags[k] = match[2] ? match[3] # quotes surrounding src: 2 - double, 3 - single
			processed_esi_tag = @processESIvars esi_tags[k]
			if esi_tags[k] isnt processed_esi_tag #esi tag contained esi variables, replace esi in body with processed one
				@subESI esi_tags[k], "<esi:include src='#{processed_esi_tag}' />"
				esi_tags[k] = processed_esi_tag
		removeDuplicates = (arr) ->
			narr = []
			obj = {}
			for k,v in arr
				obj[arr[v]] = 0
			for i of obj
				narr.push i
			return narr
		esi_tags = removeDuplicates esi_tags ? []
		return esi_tags

	@fetchESI = (src, callback) ->
		uri = url.parse(src)
		options =
			host: uri.hostname ? @request.url.hostname
			port: uri.port ? (if uri.protocol? then 80 else @request.url.port)
			path: (uri.pathname ? '/') + (uri.search ? '') + (uri.hash ? '')
		http.get(options, (res) ->
			body = ''
			res.on 'data', (chunk) =>
				body += chunk.toString()
			res.on 'end', =>
				callback src, res.statusCode, body
		).on 'error', (e) ->
			callback src, 500, e.message

	@subESI = (src, body) ->
		re = new RegExp('<esi[^>]* src=("' + RegExp.escape(src) + '"|\'' + RegExp.escape(src) + '\')[^>]*>(</esi[^>]*>)?', 'gi')
		@data = @data.replace(re, body.replace(/\$/g,'$$$')) # if story contains $ escape it
		idx = @esi_tags.indexOf(src)
		@esi_tags.splice idx, 1  unless idx is -1
		return @esi_tags.length # number of ESIs remaining

	@processESIvars = (data) ->
		re = new RegExp('\\$\\([^\\)]+\\)', 'gi')
		esi_vars = data.match(re)
		for i of esi_vars
			re = new RegExp('\\(([^{\\|\\)]*)({([^}]*)})?(\\|([^\\|{)]*))?\\)', 'i')
			esi_var = esi_vars[i].match(re)
			esi_var_result = @lookupESIvar(esi_var[1], esi_var[3])
			if !esi_var_result and esi_var[5]? # set default if exists
				esi_var_result = esi_var[5]
			data = data.replace(esi_vars[i], esi_var_result)
		data

	@lookupESIvar = (esi_var, options) ->
		result = ''
		switch esi_var.toUpperCase()
			when 'HTTP_ACCEPT_LANGUAGE'
				result = @request['accept-language']
			when 'HTTP_COOKIE'
				result = ''
				if options?
					re = new RegExp('(^| )' + options + '=([^;]*)', 'i')
					cookie = @request['cookie'] ? ''
					matches = cookie.match(re)
					if matches?
						result = matches[2]
			when 'HTTP_HEADER'
				result = @request[options]
			when 'HTTP_HOST'
				result = @request['host']
			when 'HTTP_REFERER'
				result = @request['referer']
			when 'HTTP_USER_AGENT'
				result = @request['user-agent']
			when 'QUERY_STRING'
				if options?
					result = @request.url.query[options]
				else
					result = querystring.stringify @request.url.query
		result ?= ''
		return encodeURIComponent(result)

	RegExp.escape = (text) ->
	  text.replace /[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"

	return